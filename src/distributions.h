#ifndef DISTRIBUTIONS_H
#define DISTRIBUTIONS_H

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <string.h>

// --- ВСПОМОГАТЕЛЬНЫЕ МАТЕМАТИЧЕСКИЕ ФУНКЦИИ ---
// Эта группа функций реализует сложную математику, необходимую для расчетов.
// Они являются основой для функций основных распределений.

/**
 * @brief Вычисляет модифицированную функцию Бесселя второго рода K_nu(x).
 * @param nu Порядок функции.
 * @param x Аргумент функции.
 * @return Значение K_nu(x).
 * @note Это самая сложная для реализации функция. Реализовать её самому у меня так и получилось, как бы я не старался. Пришлось установить GSL (GNU Scientific Library) и использовать ее готовую реализацию.
 */
double bessel_k(double nu, double x);

// --- ОСНОВНОЕ РАСПРЕДЕЛЕНИЕ (СГР) ---
// Эта группа функций работает с одним симметричным гиперболическим распределением,
// параметризованным сдвигом (mu), масштабом (lambda) и параметром формы (v).

/**
 * @brief Вычисляет значение плотности вероятности (PDF) основного распределения в точке x.
 * @param x Точка, в которой вычисляется плотность.
 * @param mu Параметр сдвига.
 * @param lambda Параметр масштаба.
 * @param v Параметр формы.
 * @return Значение плотности f(x; mu, lambda, v).
 */
double pdf_main(double x, double mu, double lambda, double v);

/**
 * @brief Вычисляет теоретические моменты основного распределения.
 * @param mu Параметр сдвига.
 * @param lambda Параметр масштаба.
 * @param v Параметр формы.
 * @param mean Указатель для возврата математического ожидания (M).
 * @param variance Указатель для возврата дисперсии (D).
 * @param skewness Указатель для возврата коэффициента асимметрии (γ1). Для СГР всегда ~0.
 * @param kurtosis Указатель для возврата коэффициента эксцесса (γ2).
 */
void moments_main(double mu, double lambda, double v, double *mean, double *variance, double *skewness, double *kurtosis);

// Вспомогательная функция для генерации равномерного распределения
double uniform_random();

// Вспомогательная функция для генерации стандартной нормальной величины (метод Бокса-Мюллера)
double normal_random();

/**
 * @brief Генерирует одну случайную величину, распределенную согласно основному распределению.
 * @param mu Параметр сдвига.
 * @param lambda Параметр масштаба.
 * @param v Параметр формы.
 * @return Смоделированное значение.
 * @note Реализует алгоритм из варианта (шаги 1-4).
 */
double generate_main(double mu, double lambda, double v);

// --- СМЕСЬ РАСПРЕДЕЛЕНИЙ ---
// Эта группа функций работает со смесью двух основных распределений (СГР).
// Параметры объединены в структуру MixtureParams для удобства передачи.

/**
 * @brief Структура, хранящая все параметры для распределения-смеси.
 */
typedef struct {
    double mu1, lambda1, v1; // Параметры (сдвиг, масштаб, форма) первого распределения в смеси.
    double mu2, lambda2, v2; // Параметры (сдвиг, масштаб, форма) второго распределения в смеси.
    double p;                // Вероятность выбора первого распределения (p ∈ [0, 1]).
} MixtureParams;

/**
 * @brief Вычисляет значение плотности вероятности смеси двух распределений в точке x.
 * @param x Точка, в которой вычисляется плотность.
 * @param params Указатель на структуру с параметрами смеси.
 * @return Значение плотности смеси в точке x.
 * @note Формула: f_mix(x) = p * f1(x) + (1 - p) * f2(x)
 */
double pdf_mixture(double x, MixtureParams *params);

/**
 * @brief Вычисляет теоретические моменты распределения-смеси.
 * @param params Указатель на структуру с параметрами смеси.
 * @param mean Указатель для возврата математического ожидания.
 * @param variance Указатель для возврата дисперсии.
 * @param skewness Указатель для возврата коэффициента асимметрии.
 * @param kurtosis Указатель для возврата коэффициента эксцесса.
 * @note Моменты считаются по формулам из п. 3.1.2 методички.
 */
void moments_mixture(MixtureParams *params, double *mean, double *variance, double *skewness, double *kurtosis);

/**
 * @brief Генерирует одну случайную величину, распределенную согласно смеси.
 * @param params Указатель на структуру с параметрами смеси.
 * @return Смоделированное значение.
 * @note Реализует алгоритм: с вероятностью p генерируется величина из первого распределения, иначе - из второго.
 */
double generate_mixture(MixtureParams *params);

// --- ЭМПИРИЧЕСКОЕ РАСПРЕДЕЛЕНИЕ ---
// Эта группа функций работает не с параметрами, а с готовой выборкой данных (массивом чисел).
// Сама выборка НЕ хранится внутри этих функций, а передается в качестве аргумента.

/**
 * @brief Оценивает плотность вероятности в точке x на основе предоставленной выборки.
 * @param x Точка, в которой оценивается плотность.
 * @param sample Указатель на массив с данными выборки.
 * @param sample_size Размер выборки.
 * @return Оценка плотности f(x) по выборке.
 * @note Реализация может быть разной: построение гистограммы с последующим интерполированием
 *       или использование ядерных оценок плотности (KDE). Методичка предлагает гистограмму (формула 1.4).
 */
double pdf_empirical(double x, double *sample, int sample_size);

/**
 * @brief Вычисляет выборочные (эмпирические) моменты по предоставленной выборке.
 * @param sample Указатель на массив с данными выборки.
 * @param sample_size Размер выборки.
 * @param mean Указатель для возврата выборочного среднего.
 * @param variance Указатель для возврата выборочной дисперсии.
 * @param skewness Указатель для возврата выборочного коэффициента асимметрии.
 * @param kurtosis Указатель для возврата выборочного коэффициента эксцесса.
 * @note Моменты считаются по стандартным формулам статистики (напр., выборочная дисперсия с поправкой Бесселя).
 */
void moments_empirical(double *sample, int sample_size, double *mean, double *variance, double *skewness, double *kurtosis);

/**
 * @brief Генерирует одну случайную величину, подчиняющуюся эмпирическому распределению.
 * @param sample Указатель на массив с данными выборки.
 * @param sample_size Размер выборки.
 * @return Смоделированное значение.
 * @note Реализация проста: равновероятно выбирается случайный элемент из массива 'sample'.
 */
double generate_empirical(double *sample, int sample_size);

// --- ЭКСПОРТ ДАННЫХ ДЛЯ ВИЗУАЛИЗАЦИИ ---

/**
 * @brief Структура для хранения данных одного графика
 */
typedef struct {
    char title[100];
    char filename[50];
    double *x_values;
    double *y_values;
    double *empirical_data;
    int points_count;
    int empirical_size;
} PlotData;

/**
 * @brief Генерирует данные для построения графиков распределений
 * @param test_case Номер теста (например, "3.1.1")
 * @param params Параметры распределения (для основного или смеси)
 * @param is_mixture Флаг: 0 - основное распределение, 1 - смесь
 * @param empirical_sample Выборка для эмпирического распределения (может быть NULL)
 * @param empirical_size Размер выборки для эмпирического распределения
 * @return Указатель на структуру PlotData с данными для графика
 */
PlotData* generate_plot_data(const char* test_case, MixtureParams* params, int is_mixture, 
                            double* empirical_sample, int empirical_size);

/**
 * @brief Сохраняет данные графика в файл
 * @param data Данные для сохранения
 * @return 0 при успехе, -1 при ошибке
 */
int save_plot_data(PlotData* data);

/**
 * @brief Освобождает память, занятую PlotData
 */
void free_plot_data(PlotData* data);

#endif